!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C	m,member	/struct, and union members/
!_TAG_KIND_DESCRIPTION!C	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/fedora/Desktop/42_minishell/yshimoda_minishell_test/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.0.0	//
!_TAG_ROLE_DESCRIPTION!C!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
DOUBLE_QUOTE_CHAR	include/minishell.h	/^# define DOUBLE_QUOTE_CHAR /;"	d
ERROR_PARSE	include/minishell.h	/^# define ERROR_PARSE /;"	d
ERROR_PREFIX	src/error.c	/^#define ERROR_PREFIX /;"	d	file:
ERROR_TOKENIZE	include/minishell.h	/^# define ERROR_TOKENIZE /;"	d
LINUX	include/minishell.h	/^# define LINUX$/;"	d
MINISHEll_H	include/minishell.h	/^# define MINISHEll_H$/;"	d
ND_REDIR_OUT	include/minishell.h	/^	ND_REDIR_OUT,$/;"	e	enum:e_node_kind
ND_SIMPLE_CMD	include/minishell.h	/^	ND_SIMPLE_CMD,$/;"	e	enum:e_node_kind
PATH_MAX	src/main.c	/^#define PATH_MAX /;"	d	file:
SINGLE_QUOTE_CHAR	include/minishell.h	/^# define SINGLE_QUOTE_CHAR /;"	d
TK_EOF	include/minishell.h	/^	TK_EOF,$/;"	e	enum:e_token_kind
TK_OP	include/minishell.h	/^	TK_OP,$/;"	e	enum:e_token_kind
TK_RESERVED	include/minishell.h	/^	TK_RESERVED,$/;"	e	enum:e_token_kind
TK_WORD	include/minishell.h	/^	TK_WORD,$/;"	e	enum:e_token_kind
append_char	src/expand.c	/^void	append_char(char **s, char c)$/;"	f	typeref:typename:void
append_command_element	src/parse.c	/^void	append_command_element(t_node *command, t_token **rest, t_token *tok)$/;"	f	typeref:typename:void
append_node	src/parse.c	/^void	append_node(t_node **node, t_node *elm)$/;"	f	typeref:typename:void
append_tok	src/parse.c	/^void	append_tok(t_token **tok, t_token *elm)$/;"	f	typeref:typename:void
args	include/minishell.h	/^	t_token		*args;$/;"	m	struct:s_node	typeref:typename:t_token *
assert_error	src/error.c	/^void	assert_error(const char *msg)$/;"	f	typeref:typename:void
at_eof	src/parse.c	/^bool	at_eof(t_token *tok)$/;"	f	typeref:typename:bool
consume_blank	src/tokenize.c	/^bool	consume_blank(char	**rest, char *line)$/;"	f	typeref:typename:bool
do_redirect	src/redirect.c	/^void	do_redirect(t_node *redir)$/;"	f	typeref:typename:void
e_node_kind	include/minishell.h	/^enum e_node_kind$/;"	g
e_token_kind	include/minishell.h	/^enum e_token_kind$/;"	g
equal_op	src/parse.c	/^bool	equal_op(t_token *tok, char *op)$/;"	f	typeref:typename:bool
err_exit	src/error.c	/^void	err_exit(const char *location, const char *msg, int status)$/;"	f	typeref:typename:void
exec	src/main.c	/^int	exec(t_node *node)$/;"	f	typeref:typename:int
exec_cmd	src/main.c	/^int	exec_cmd(t_node *node)$/;"	f	typeref:typename:int
expand	src/expand.c	/^void	expand(t_node *node)$/;"	f	typeref:typename:void
expand_quote_removal	src/expand.c	/^void	expand_quote_removal(t_node *node)$/;"	f	typeref:typename:void
fatal_error	src/error.c	/^void	fatal_error(const char *msg)$/;"	f	typeref:typename:void
filefd	include/minishell.h	/^	int			filefd;$/;"	m	struct:s_node	typeref:typename:int
filename	include/minishell.h	/^	t_token		*filename;$/;"	m	struct:s_node	typeref:typename:t_token *
free_argv	src/destructor.c	/^void	free_argv(char **argv)$/;"	f	typeref:typename:void
free_node	src/destructor.c	/^void	free_node(t_node *node)$/;"	f	typeref:typename:void
free_tok	src/destructor.c	/^void	free_tok(t_token *tok)$/;"	f	typeref:typename:void
interpret	src/main.c	/^void	interpret(char *line, int *stat_loc)$/;"	f	typeref:typename:void
is_blank	src/tokenize.c	/^bool	is_blank(char c)$/;"	f	typeref:typename:bool
is_metacharacter	src/tokenize.c	/^bool	is_metacharacter(char c)$/;"	f	typeref:typename:bool
is_operator	src/tokenize.c	/^bool	is_operator(const char *s)$/;"	f	typeref:typename:bool
is_word	src/tokenize.c	/^bool	is_word(const char *s)$/;"	f	typeref:typename:bool
kind	include/minishell.h	/^	t_node_kind	kind;$/;"	m	struct:s_node	typeref:typename:t_node_kind
kind	include/minishell.h	/^	t_token_kind	kind;$/;"	m	struct:s_token	typeref:typename:t_token_kind
main	src/main.c	/^int main(void)$/;"	f	typeref:typename:int
new_node	src/parse.c	/^t_node	*new_node(t_node_kind kind)$/;"	f	typeref:typename:t_node *
new_token	src/tokenize.c	/^t_token	*new_token(char *word, t_token_kind kind)$/;"	f	typeref:typename:t_token *
next	include/minishell.h	/^	t_node		*next;$/;"	m	struct:s_node	typeref:typename:t_node *
next	include/minishell.h	/^	t_token			*next;$/;"	m	struct:s_token	typeref:typename:t_token *
open_redir_file	src/redirect.c	/^void	open_redir_file(t_node *redir)$/;"	f	typeref:typename:void
operator	src/tokenize.c	/^t_token	*operator(char **rest, char *line)$/;"	f	typeref:typename:t_token *
parse	src/parse.c	/^t_node	*parse(t_token *tok)$/;"	f	typeref:typename:t_node *
parse_error	src/error.c	/^void	parse_error(const char *location, t_token **rest, t_token *tok)$/;"	f	typeref:typename:void
perror_prefix	src/error.c	/^static void	perror_prefix(void)$/;"	f	typeref:typename:void	file:
redirect_out	src/parse.c	/^t_node	*redirect_out(t_token **rest, t_token *tok)$/;"	f	typeref:typename:t_node *
redirects	include/minishell.h	/^	t_node		*redirects;$/;"	m	struct:s_node	typeref:typename:t_node *
remove_double_quote	src/expand.c	/^void	remove_double_quote(char **dst, char **rest, char *p)$/;"	f	typeref:typename:void
remove_quote	src/expand.c	/^void	remove_quote(t_token *tok)$/;"	f	typeref:typename:void
remove_single_quote	src/expand.c	/^void	remove_single_quote(char **dst, char **rest, char *p)$/;"	f	typeref:typename:void
reset_redirect	src/redirect.c	/^void	reset_redirect(t_node *redir)$/;"	f	typeref:typename:void
s_node	include/minishell.h	/^struct s_node$/;"	s
s_token	include/minishell.h	/^struct s_token$/;"	s
search_path	src/main.c	/^char	*search_path(const char *filename)$/;"	f	typeref:typename:char *
startswith	src/tokenize.c	/^bool	startswith(const char *s, const char *keyword)$/;"	f	typeref:typename:bool
stashed_targetfd	include/minishell.h	/^	int			stashed_targetfd;$/;"	m	struct:s_node	typeref:typename:int
stashfd	src/redirect.c	/^int	stashfd(int fd)$/;"	f	typeref:typename:int
strlcat	src/strlcat.c	/^size_t	strlcat(char *restrict dst, const char *restrict src, size_t dstsize)$/;"	f	typeref:typename:size_t
strlcpy	src/strlcpy.c	/^size_t	strlcpy(char *restrict dst, const char *restrict src, size_t dstsize)$/;"	f	typeref:typename:size_t
syntax_error	src/error.c	/^bool	syntax_error = false;$/;"	v	typeref:typename:bool
t_node	include/minishell.h	/^typedef struct s_node		t_node;$/;"	t	typeref:struct:s_node
t_node_kind	include/minishell.h	/^typedef enum e_node_kind	t_node_kind;$/;"	t	typeref:enum:e_node_kind
t_token	include/minishell.h	/^typedef struct s_token		t_token;$/;"	t	typeref:struct:s_token
t_token_kind	include/minishell.h	/^typedef enum e_token_kind	t_token_kind;$/;"	t	typeref:enum:e_token_kind
tail_recursive	src/tokenize.c	/^char	**tail_recursive(t_token *tok, int nargs, char **argv)$/;"	f	typeref:typename:char **
targetfd	include/minishell.h	/^	int			targetfd;$/;"	m	struct:s_node	typeref:typename:int
todo	src/error.c	/^void	todo(const char *msg)$/;"	f	typeref:typename:void
tokdup	src/parse.c	/^t_token	*tokdup(t_token *tok)$/;"	f	typeref:typename:t_token *
token_list_to_argv	src/tokenize.c	/^char	**token_list_to_argv(t_token *tok)$/;"	f	typeref:typename:char **
tokenize	src/tokenize.c	/^t_token	*tokenize(char *line)$/;"	f	typeref:typename:t_token *
tokenize_error	src/error.c	/^void	tokenize_error(const char *location, char **rest, char *line)$/;"	f	typeref:typename:void
validate_access	src/main.c	/^void	validate_access(const char *path, const char *filename)$/;"	f	typeref:typename:void
word	include/minishell.h	/^	char			*word;$/;"	m	struct:s_token	typeref:typename:char *
word	src/tokenize.c	/^t_token	*word(char **rest, char *line)$/;"	f	typeref:typename:t_token *
xperror	src/error.c	/^void	xperror(const char *location)$/;"	f	typeref:typename:void
